From bf4f659c3c66293dcf73659a293defbcc1b95b99 Mon Sep 17 00:00:00 2001
From: Carlos Rodriguez <carlos@s8f.org>
Date: Mon, 17 Oct 2011 18:27:24 -0700
Subject: [PATCH 1/1] Counter-based cache tags in D7.

---
 includes/cache.inc |  113 +++++++++++++++++++++++++++++++++++++++++++++++++--
 1 files changed, 108 insertions(+), 5 deletions(-)

diff --git a/includes/cache.inc b/includes/cache.inc
index 8666874..95cbb05 100644
--- a/includes/cache.inc
+++ b/includes/cache.inc
@@ -132,9 +132,15 @@ function cache_get_multiple(array &$cids, $bin = 'cache') {
  *     general cache wipe.
  *   - A Unix timestamp: Indicates that the item should be kept at least until
  *     the given time, after which it behaves like CACHE_TEMPORARY.
+ * @param $tags
+ *   An array of tags to be stored with the cache item. These should normally
+ *   identify objects used to build the cache item, which should trigger
+ *   cache invalidation when updated. For example if a cached item represents
+ *   a node, both the node ID and the author's user ID might be passed in as
+ *   tags. For example array('node' => array(123), 'user' => array(92)).
  */
-function cache_set($cid, $data, $bin = 'cache', $expire = CACHE_PERMANENT) {
-  return _cache_get_object($bin)->set($cid, $data, $expire);
+function cache_set($cid, $data, $bin = 'cache', $expire = CACHE_PERMANENT, $tags = array()) {
+  return _cache_get_object($bin)->set($cid, $data, $expire, $tags);
 }
 
 /**
@@ -271,8 +277,14 @@ interface DrupalCacheInterface {
    *     general cache wipe.
    *   - A Unix timestamp: Indicates that the item should be kept at least until
    *     the given time, after which it behaves like CACHE_TEMPORARY.
+   * @param $tags
+   *   An array of tags to be stored with the cache item. These should normally
+   *   identify objects used to build the cache item, which should trigger
+   *   cache invalidation when updated. For example if a cached item represents
+   *   a node, both the node ID and the author's user ID might be passed in as
+   *   tags. For example array('node' => array(123), 'user' => array(92)).
    */
-  function set($cid, $data, $expire = CACHE_PERMANENT);
+  function set($cid, $data, $expire = CACHE_PERMANENT, $tags = array());
 
 
   /**
@@ -332,7 +344,7 @@ class DrupalDatabaseCache implements DrupalCacheInterface {
       // is used here only due to the performance overhead we would incur
       // otherwise. When serving an uncached page, the overhead of using
       // db_select() is a much smaller proportion of the request.
-      $result = db_query('SELECT cid, data, created, expire, serialized FROM {' . db_escape_table($this->bin) . '} WHERE cid IN (:cids)', array(':cids' => $cids));
+      $result = db_query('SELECT cid, data, created, expire, serialized, tags, checksum FROM {' . db_escape_table($this->bin) . '} WHERE cid IN (:cids)', array(':cids' => $cids));
       $cache = array();
       foreach ($result as $item) {
         $item = $this->prepareItem($item);
@@ -401,6 +413,14 @@ class DrupalDatabaseCache implements DrupalCacheInterface {
       return FALSE;
     }
 
+    // The cache data is invalid if any of its tags have been cleared since.
+    if ($cache->tags) {
+      $cache->tags = explode(' ', $cache->tags);
+      if (cache_tags()->isExpired($cache->checksum, $cache->tags)) {
+        return FALSE;
+      }
+    }
+
     if ($cache->serialized) {
       $cache->data = unserialize($cache->data);
     }
@@ -408,11 +428,13 @@ class DrupalDatabaseCache implements DrupalCacheInterface {
     return $cache;
   }
 
-  function set($cid, $data, $expire = CACHE_PERMANENT) {
+  function set($cid, $data, $expire = CACHE_PERMANENT, $tags = array()) {
     $fields = array(
       'serialized' => 0,
       'created' => REQUEST_TIME,
       'expire' => $expire,
+      'tags' => implode(' ', cache_tags()->flatten($tags)),
+      'checksum' => cache_tags()->checksum($tags),
     );
     if (!is_string($data)) {
       $fields['data'] = serialize($data);
@@ -506,3 +528,84 @@ class DrupalDatabaseCache implements DrupalCacheInterface {
     return empty($result);
   }
 }
+
+interface DrupalCacheTagsInterface {
+  function __construct();
+
+  function expire($tags);
+
+  function checksum($tags);
+
+  function isExpired($checksum, $tags);
+}
+
+abstract class DrupalCacheTags {
+  function __construct() {
+
+  }
+
+  function flatten($tags) {
+    if (isset($tags[0])) return $tags;
+    $flat_tags = array();
+    foreach ($tags as $namespace => $values) {
+      foreach ($values as $value) {
+        $flat_tags[] = "$namespace:$value";
+      }
+    }
+    return $flat_tags;
+  }
+
+  function isExpired($checksum, $tags) {
+    return $checksum < $this->checksum($tags);
+  }
+}
+
+class DrupalDatabaseCacheTags extends DrupalCacheTags implements DrupalCacheTagsInterface {
+  protected $tag_cache = array();
+
+  function expire($tags) {
+    foreach ($this->flatten($tags) as $tag) {
+      unset($this->tag_cache[$tag]);
+      db_merge('cache_tags')
+        ->key(array('tag' => $tag))
+        ->fields(array('invalidations' => 1))
+        ->expression('invalidations', 'invalidations + 1')
+        ->execute();
+    }
+  }
+
+  function checksum($tags) {
+    $checksum = 0;
+    $query_tags = array();
+
+    foreach ($this->flatten($tags) as $tag) {
+      if (isset($this->tag_cache[$tag])) {
+        $checksum += $this->tag_cache[$tag];
+      }
+      else {
+        $query_tags[] = $tag;
+      }
+    }
+    if ($query_tags) {
+      if ($db_tags = db_query('SELECT tag, invalidations FROM {cache_tags} WHERE tag IN (:tags)', array(':tags' => $query_tags))->fetchAllKeyed()) {
+        $this->tag_cache = array_merge($this->tag_cache, $db_tags);
+        $checksum += array_sum($db_tags);
+      }
+    }
+
+    return $checksum;
+  }
+}
+
+function cache_tags() {
+  $object = &drupal_static(__FUNCTION__);
+  if (!isset($object)) {
+    $class = variable_get('cache_tags_class', 'DrupalDatabaseCacheTags');
+    $object = new $class;
+  }
+  return $object;
+}
+
+function cache_expire_tagged($tags) {
+  return cache_tags()->expire($tags);
+}
-- 
1.7.4.1

